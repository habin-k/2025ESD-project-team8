00:21 이동희 박종훈 장동하 조현근 후배 정현돈 이승무 당무원 신규민 네 이윤영 김재용 김준혁 배정이 김필준 강보현 유민상 하성현 김준희 장성준 박태성 김선일 박병준 네 박서인 이시현 네 부사연 이종원 예 어 김하담 음현수 이준호 그리고 이다현 서승연 최원영 정서현 이주헌 박정우 시험은 잘 보셨나요?
02:06 한 학생이 엄청 잘했던데 거의 만점에 가지고 저도 못 풀었을 것 같은데, 전반적으로 만점에 가까운 점이 있다는 거는 시험 문제는 크게 문제가 없었다는 거죠. 성적이 낮다면 여러분한테 문제가 있는 거죠. 아니 뭐 전반적으로 봤을 때 뭐 그게 기말대하고 훨씬 더 차이가 많이 나요? 영어보다는 큰 점수 차이가 나는 건 아니에요. 네 지금 여러분이 AMBA부터 시작해서 이 다음번 메모리하고 이제 데이터 무슨 디지털 블록이라는 게 있거든요. 요새 중요한 다음 노트가 제가 어제 올려드렸는데 오늘 아마 진도를 나갈 것 같은데, 그 노트가 사실 조금 난이도가 있습니다.
03:00 난이도가 있어 가지고 마지막은 메모리인데 메모리는 여러분이 다른 수업에서 듣고 그래 가지고 좀 기본적으로 나왔는데 다음번에 나오는 그게 좀 난이도가 있어서, 거기서 시험 문제가 많이 나오기 때문에 어려울 것 같고요. 거기서 차이가 많이 납니다. 그래서 이 AMBA같은 경우에는 사실 뭐 문제가 나오는 유형을 제가 말씀드릴 거예요. 말씀드릴 거고, 다만 이거는 교재에 따로 없거든요. 다음번에 나오는 내용들은 사실은 교재라고 하는 웨스트 vlsi에서 썼던 교재의 내용이 상당히 있어요.
03:49 있는데, 거기 설명이 좀 자세하게 없어서 사실은 자체 내용이 좀 어려운 거에 비해서 설명이 부족해서 교과서를 봐도 잘 이해가 안 되는 그런 상황일 수가 있고 지금 얘기하는 예는 아예 교과서에 없거든요. 그러니까 노트에만 의존하기 때문에 설명이 부족하다고 느끼면은 잘 이해를 못 하는 정도 있는데, 하여튼 대신 제가 어떤 시험 문제가 나온다라는 거는 말씀을 나중에 드릴까 합니다. 중간고사는 큰 차이는 없고 그리고 아주 잘한 부분이 놀라울 정도로 잘한 분이 있더라고요. 있는데, 이름은 잘 기억은 없다기 때문에 한 분이 없고 그랬고 나머지는 그냥 노만하게 하셨어요. 하기 때문에 결국 기만해서 차이가 많이 난다 이해하시면 되겠습니다. 일단 우리가 AMBA를 얘기를 하고 있고요.
04:43 AMBA를 얘기하고 있는데, 어 AMBA라는 건 이제 결국 우리가 설계자의 측면에서 봤을 때 아직 버스라는 게 사실 master, slave끼리 통신하는 건데, 이제 우리가 mater 하나면 사실 문제가 될 게 없어요.
05:07 보통 프로세서가 master인데 이제 보통은 일반적으로 봤을 때 버스가 복잡한 거는 멀티master multi slave가 되는, 그래서 이제 master를 주로 선택하는 걸 이제 우리가 arbiter라는 회로가 있어 가지고 어떤 master가 버스를 소유할 거냐 이렇게 컨트롤 할 거냐 결정하는 게 arbiter고 그다음에 이제 우리가 보통은 어떤 주소를 가지고 내가 어느 slave하고 통신할지를 결정하는데 그래서 이제 그걸 갖다가 우리가 하는 회로를 우리가 이제 address decoder라고 한다. 그래서 버스를 기본적으로 설계하려고 그러면 master 설계를 할 수 있어야 되고요.
05:57 통신을 위한 master죠. 프로세서라고 하더라도, 뭐 프로세서가 뭐 cpu, gpu라고 했을 때, 뭐 굳이 뭐 내가 어떤 연산을 한다. 이런 게 중요한 게 아니라, 결국 통신을 하기 위한 master 쪽 인터페이스, 그다음에 이제 slave도 마찬가지죠, 우리가 메모리를 얘기할 때 결국 데이터를 주고받기 위한 master하고, 통신을 위한 인터페이스, 그다음에 이제 master가 버스를 사용하고 싶어 할 때 일단 버스 request라는 걸 하는데, request를 받아서 이제 어떤 놈한테 버스를 줄 거냐를 이제 이걸 request라고 하고, 보통 주는 걸 grant라고 합니다. 버스 grant. arbiter라는 거는 결국 이 request를 받아서 어떤 어떤 방법에 의해서, 방법이라는 건 딱 정해진 건 없고요.
06:50 어떤 방법에 의해서 하여튼 누구한테 어떤 master한테 버스에 사용할 권리를 주죠 그러고 나서는 결국 master가 그러면 내가 사용한다. 그 다음부터 주로 하는 건 read/write 겠죠, 메모리라고 하면. 메모리에서 데이터를 읽어오거나, 데이터를 저장하거나. send/receive라고 볼 수도 있고 read/write, 그런 것으로 인정을 하게 되고 그럴 때 주로 우리가 보통은, 특히 io 용어 중에서, memory mapped io라는 게 있거든요. 그다음에 이제 무슨 dedicated io. 이건 좀 옛날 용어예요. 이건 io 장치하고 프로세서가 통신할 때 얘를 위한 명령어가 따로 있는 거죠.
07:45 그러니까 다시 말하자면, 우리가 사실 프로세서가 통신한다는 거는 소위 말하는 메인 메모리하고 통신하는 경우와 그다음에 아이오 장치와 통신하는 경우로 크게 나눌 수가 있는데, 이럴 때 이제 우리가 memory mapped io라는 거는 명령어가 같은 거죠. 그냥 read/write라고 쓰는 거예요. 그리고 이 메모리 맵 중에 주소를 가지고 주소를 우리가 할당해서 특정 주소와 통신하면, 그게 메인 메모리가 될 수도 있고, io 장치가 될 수도 있는 거죠. 그래서 우리가 memory mapped io라고 하고. dedicated io 또는 separate io라고 부르는 거는 실제로 명령어가 다른 거예요.
08:35 우리가 메인메모리를 access 한다거나, in/out을 한다거나 하는 걸 완전히 명령어 단계에서 구분하는 걸 우리가 이제 dedicated io 또는 separate io로 얘기합니다. 근데 이제 일반적으로 memory mapped io가 굉장히 일반적이에요. 그래서 우리도 이제 AMBA 버스에서 하는 경우에는 결국은 이제 memory mapped io를 쓴다고 생각하는 거죠. 대부분의 현재 나온 프로세스들은 memory mapped io를 쓰고 특히 RISC 같은 계열로 들어가게 되면 당연히 RISC라는 것 자체가 명령어의 개수를 줄이는 게 목적 중에 하나잖아요. 그러니까 우리가 당연히 명령어를 개수를 줄인다는 얘기는 read/write 명령어 하나 가지고 IO 액세스하고 메모리 액세스를 했다는 얘기고, 그럴 때 결국 우리가 핵심이 되는 건 뭐냐면 주소예요, 주소. 그래서 저희가 이 주소를 가지고 이제 우리가 어떤 slave를 선택하게 돼요.
09:34 그래서 여러분이 버스를 설계할 일이 없을지는 모르겠지만, 있을 수 있고 없을 수도 있는데, 근데 이제 기본적으로는 아마 이렇게 크게 4가지. master interface, slave interface, arbiter, decoder를 설계하는 거다. 지난 지난주에 수업 마지막 할 때 그런 얘기 했던 것 같아요. 네 가지를 여러분이 잘 이해하면 되고요. 
 AMBA라는 건 이제 사실은 어떤 하드웨어를 얘기하는 게 아니라 프로토콜이죠. 통신할 때 이런 약속을 한다는 얘기니까. 그래서 우리가 특히 온칩 버스이기 때문에 모든 통신들이 parallel로  돌아가고요.
10:20 (53페이지) 그렇기 때문에 데이터 버스의 크기는 그냥 32bit부터 한 256bit 정도로 정해 놓고 그러니까 이거는 뭐 구현하는 사람에 따라서 니 칩 안에 있는 버스니까 알아서 니가 편한 만큼 써라 이렇게 되는 거죠. 정해준 건, 최소 32. 그 이상. 이렇게 얘기하면 되는 거고, 다만 address는 32bit로 통일한다. 이렇게 얘기하는 거고요. 그다음에 기본적으로 ahb의 경우에는 multi master, multi slave를 가져가는 거고, 그다음에 여러 가지 이런 거 뒤에 나올 테니까. 말씀드릴 것 같고요. 기본적으로 synchronous하다는 얘기는 클럭이 있어가지고 그러니까 기본적으로 amba의 기본적인 프로토콜은 axi도 그렇고요. two cycle 프로토콜이에요.
11:07 two cycle 프로토콜 해가지고, 항상 첫 번째 사이클에서는 우리가 쉽게 얘기하면 주소와  커맨드. 쉽게 얘기하면 read할지 write 할지 정하고, 그다음에 두 번째 사이클이 끝나는 시점. 이 시점이 데이터가 실제로 주고받아지는. 기본은 이렇게 두 사이클로 통신을 하는 거죠. 제가 synchronous한 프로토콜이 심플하다, 심플하기 때문에 구현하기가 쉽고 하기도 쉽고. 다행히 모든 통신들은 하이스피드한 통신들은 synchronous한 걸 갖고 있는 게 맞구요.
11:50 AMBA도 마찬가지고 synchronous해서, 클럭이 있다고 가정하고 클럭 신호 자체에, 특히 온칩에서는 사실, 이게 뭐 칩 와이어 그러니까 우리가 외부로 나가는 오프칩 통신을 하게 되면 클럭에 따로 와이어를 할당해야 되는데 이게 부담이 될 수가 있거든요. 오프칩 경우에는. 그래서 우리가 클럭 신호를 따로 두는 걸 되게 피하고 싶기 때문에 사실은 어떤 데이터 신호에다가 클럭 신호를 같이 얹어 보내는 경우가 오프칩 통신에서 많이 있는데, 온칩 통신에서야 공간 여유가 있으니까 당연히 클럭 신호를 따로 둬 가지고 클럭에 의해서 통신이 이루어진다고 봅니다. 그다음에 Multiplexed implementation이라는 건 기본적으로 먹스를 많이 쓴다는 얘기예요.
12:39 기본적으로는 먹스를 써가지고 이제 우리가 master가 여러 개 있을 때 arbiter가 선택할 때도 그럴 때 보통 다 먹스를 쓴다는 얘기죠. (54페이지) 그래서 이제 우리가 기본적으로 하드웨어를 생각한다면, 대충 기본 골격은 이래요. 대표적으로 해서 arbiter, decoder, multi master, multi slave가 있는 거고, 아까도 얘기했지만, 처음에 일단은 master가 버스를 사용하고 싶으면 이 master 쪽 인터페이스에 버스 리프레이스라는 게 있습니다. 리퍼스 리페스트를 보내면 보내면 아비타에서 나름대로 동시에 어느 리페스트가 오게 되면 우선순위를 두든 어떤 알고리즘을 정한 건 아니에요.
13:29 정한 건 아니지만, 리프레스를 받아가지고, 얘가 만약 레스카 1한테 버스를 주고 싶다 그러면 이제 얘가 신호를 이렇게 주는 거죠. 버스 grant를 주면 grant 신호라는 것은 뒤에서 자세히 말씀드리겠지만, arbiter가 그래프 신호를 준다는 건 뭐냐면 현재 request한 애들 중에서는 네가 제일 우선순위가 높다 너한테 줄 거야. 라는 걸 의미하지만 완전히 버스를 준 상태는 아닙니다. 너한테 줄 거야. 알려주는 거지 비슷해 그러니까 무슨 얘기냐면 버스라는 게 이제 막 뭔가 진행되고 있을 거 아니에요. 진행되는 도중에 리프레스트가 와 그러면 다음에 너한테 줄게 이게 끝나면 지금 게 끝나면 너한테 줄게라는 게 되는 거고, 그래서 우리가 기본적 브랜드라는 건 알려주는 거고, 알려준다는 것 자체가 바로 얘가 사용할 수 있는 건 아닙니다.
14:26 사용할 수는 아니고 그러다가 이제 실제로 어떤 일이 끝나게 되면 끝나게 돼서 이제 내가 버스를 나한테 만들어 주고 싶다. 그럴 때 주는 신호가 이제 여기 AMBA버스 얘기하는 에이치 베스트라는 신호입니다. master라는 신호를 봤을 때 그때 이제 아 이 버스를 누가 이 버스에 대한 정보가 어떤 어떤 master에 대한 정보구나 라는 걸 알려주는 거죠. 그러니까 이제 우리가 뒤에 타이밍 다이어링을 보시면 알겠지만, 일단 퀘스트가 오고 한두 사이클 있다가 grant가 오고 그러다 보면 이제 한 세트가 끝나게 되면 그러면 이제 기본적으로 이제 master가 바뀌게 되면서 실제로 버스 사용처가 달라집니다. 그래서 우리가 실제로 master를 통해서 실제로 어떤 말하자면, 아비터가 선택을 준 거예요. 그려주는 거고, 그러면 아까도 얘기했지만, 우리가 동시에 여러 개의 master들이 뭔가 것을 사용하고 싶을 때 이 master를 통해서 master가 하나를 선택합니다.
15:26 자연스럽게 그래서 master가 관리하겠다. 그런데 master가 주는 정보라는 게 아까 처음에 얘기했지만, 크게 두 가지예요. 그러니까 어느 주소를 가지고 얘기할 거냐 메모리 몇 도 아이오에서 그리고 위드할지 라이트 할지 깊게 봤을 때 샌드 할지 위스로 할지 이런 거죠. 이게 첫 사이클에 가는 거예요. 첫 사이클에 간다는 얘기는 우리가 이제 주소를 주게 되면 얘가 메서 선택을 하면 걔가 이제 이 주소가 이렇게 가겠죠. 그러면은 그 master의 어떤 선택된 master에 말하자면, 주소 원하는 주소를 decoder에 가게 되고 decoder에 가게 되면 여러분들이 decoder에서 이제 선택하게 됩니다. 선택할 때 결국은 이제 우리가 이 중에 하나를 선택하겠죠. 1 0 0 이런 식으로 선택해 가지고 하고 그다음에 여기도 h 슬랩이라는 시도가 있는데요.
16:20 여기서 문제 없는데 제가 끌어놓는데 여기에 이제 1번 이렇게 하겠죠. 그래서 우리가 이제 0 1 2 이렇게 있으면 이게 이게 1 2 3이라고 하여튼 모든 간에 있거든요. 다 선택된 거 이거를 선택해서 리코더가 그렇게 내놓는 거는 어떤 특정 slave에 ship 슬랙 그러면 ship 인에이블을 읽힐 수 있는 건데 특정 slave를 선택하게 하고 주소를 받아서 이렇게 하고 이제 주소를 받아서 선택한 다음에 이번 주에 통신으로 쓴다는 얘기가 되겠습니다. 여기서 이제 우리가 그 여기 t 마이너스 원을 원하면 딜레이라고 하거든요. 원사이클 딜레이 그게 무슨 얘기냐면 결국은 아까도 얘기했지만, 이 기본적인 AMBA의 어떤 통신 프로토콜은 여기서 주소하고 커맨드를 읽은 다음에 여기서 데이터가 오잖아요.
17:15 그러니까 데이터를 선택하는 거는 한 사이클 뒤에 이루어져야 되죠. 이해를 선택하고 이해를 선택하는 부분보다 그래서 우리가 한 사이클 뒤에 데이터가 불가능합니다. 이건 사실 한 사이클 뒤에라고도 얘기할 수 있지만 아까 제가 얘기할 때 hmester로 넘길 때는 좀 더 정확한 의미는 뭐냐면 주소하고 cmand line을 어떤 master가 컨트롤 할 거냐 그런데 우리가 데이터머스의 경우에는 앞에서 막 진행되는 일이 있거든요. 앞에서 그냥 완벽하게 끝나면 끝나고 다음부터 시작하는 게 제일 좋긴 좋은데 앞에서 끝나는 것들이 좀 딜레이가 되는 경우도 있을 수 있거든요. 그죠 전자력에서 뭐 노력이 다 안 끝났어요. 그래서 사실은 이 부분은 사실은 두 사이클 세 사이클이 될 수도 있어요.
18:11 뒤에 얘가 나오는데 그러니까 결과적으로 보면 우리가 버스를 준다는 거는 결국 주소 라인하고 커맨드 라인에 대한 권리를 어느 매스턴에서 준다는 거죠. 그런데 이제 데이터 라인 자체는 앞에서 있는 것들이 안 끝났으면 그걸 끝날 때까지는 새로운 게 못 잡히는 거 딜레이가 되는 거죠. 그래서 여기서 t라고 하는 이 딜레이라는 것들은 뒤에 얘가 나올 때 바로 말씀드릴 건데 결국은 이제 결국은 이 데이터 버스가 컨트롤되는 시점은 조금의 딜레이가 있다. 최소한 한 사이클 딜레이가 있고 그다음에 앞에 게 안 끝났으면 더 딜레이가 생길 수도 있다. 그렇게 이해하는 측면에서 여기 써있는 거고요. 기본적으로 그게 이제 돌아가는 거고요. 약간의 무슨 예를 들어서 우리가 여러 가지 있을 수 있겠죠.
19:08 예를 들어 우리가 에러가 발생했다든가 아니면 master가 slave가 데이터 리드를 하는데 두 번째 사이클에 데이터를 올려놔야 되는데 어떤 이유로 인해서 딜레이가 생겼다거나 아니면 에스터가 자기가 바쁜 일이 있어 가지고 계속 동작을 해야 되는데 뭔가 못하고 있다거나 그런 특이사항들 이런 것들을 복잡하게 하는 거고, 기본적인 어떤 동작은 이 그림으로 다 설명이 됐다고 볼 수 있습니다. 그래서 이렇게 하면 되고요. 그래서 설명이 되고 그래서 이제 우리가 주로 보면 이제 이게 주소가 가는 거 그다음에 그다음에 실제 데이터가 오는 거 되는 거죠. 데이터를 예를 들어서 우리가 얘한테 받기로 했다. 그러면 얘가 이제 h slave가 얘를 선택한 거거든요.
19:53 1 2 3번 있으면 일본에 가지고 선택할 거고, 그다음에 이제 그럼 여기서 얘를 선택하면 이 부분은 사실은 그림에 명확히 안 나와 있는데, 당연히 이제 우리가 여기 이런 어떤 트라이스드 범퍼 같은 걸 넣어가지고 얘하고 통신할 거면 얘만 받아들이고 얘는 차단시키는 그런 것들도 필요하겠죠. 디머크스라는 걸 쓰든 뭐 아니면 뭐 프라이스테이트 버퍼를 쓰든 뭐 하여튼 동시에 다 읽으면 안 되니까. 가만 안 두니까 연결선은 돼 있는데, 이제 그림의 생략도 있지만 뭔가 그런 게 좀 들어가긴 해야 될 것 같아요. 하여튼 뭐 그렇다는 얘기고요. 라이트 할 때는 이제 우리가 데이터를 주는 건데 특히 데이터를 줄 때도 마찬가지죠 우리가 사실 이제 이 master가 라이트할 때 특히 이제 여기 무슨 무슨 얘기냐면 결국 내가 어떤 천 번지에 내가 데이터를 라이트 하고 싶어 라고 얘기하면 사실은 데이터도 매스트해서 가는 거잖아요.
20:48 그러면 사실은 개념적으로 보면 사실은 그냥 데이터를 바로 어떤 천번지하고 라이트하는 거 하면서 동시에 버스에 올려놓을 수도 있어요. 근데 이제 그렇게 안 한다는 거죠. 왜냐면은 이게 우리가 뒤에 보면 앞에 보면 파이프라인처럼 동작을 하거든요. 이렇게 ada 주소 데이터 주소 데이터 하면 이런 식으로 동작을 하기 때문에 사실은 내가 어떤 어떤 주소를 올려놓을 때 이 데이터 버스가 앞에 있는 어떤 그 버스 트랜잭션을 위해 사용되고 있거든요. 그럴 수 있잖아요. 그렇기 때문에 우리가 이제 얘를 갖다가 데이터를 올려놓을 때 이게 다른 용도로 이 버스가 사용될 수 있기 때문에 배타민 여기서 데이터를 올려놓을 때는 반드시 두 번째 사이클 그래서 여기에 어 데이터 올려놓을 때도 역시 한 사이클 딜레이를 한 다음에 그다음에 올려놓잖아요.
21:46 그래서 그 정도만 여러분들이 이해하면 될 것 같습니다. 아비트레이션 자체는 사실 뭐 오프 측 얘기할 때는 오프스 통신 뭐 usb든 아니면 이더넷이든 뭐 아니면 다른 거든. 뭐 간에 일단은 이제 아비트레이션이 되게 재밌는 게 많이 있는데, isps든 이거는 이제 오프스님 얘기고 몸집에서는 그냥 우리가 뭐 공간도 여유가 있고 와이어 와이어링을 하는 그 선을 연결하는 영역도 있기 때문에 AMBA에서는 그냥 이걸 이제 패럴을 아비추레이션이라고 얘기하는데 그냥 어떤 회로가 있어서 동시에 이렇게 리프레스를 받아서 그중에 하나의 브랜드를 준다. 이렇게 해서 얘기하는 거고, 이 안에 어떤 걸 쓰느냐는 어떤 프라이드를 주느냐 이런 것들은 사실은 그냥 반반 프로토콜에서는 정해주지 않고요. 버스 설계자한테 네가 알아서 해라 이렇게 decoder는 여기가 알겠습니다. 주소를 받아가지고, 이제 예를 들어서 슬랙트 하는 거죠.
22:46 컴퓨터는 우리가 이제 보통은 일반적으로 보면 이제 chipinabel 또는 chipslect 이래 가지고 cs 또는 c라고 하는 슬랙 레보텀 이런 핀이 있습니다. 핀에다가 이제 decoder를 decoder 출력을 연결하게 되면 이 주소에 해당하는 주소 영역이 있겠죠. 주소를 바운드로 되어 있는 해당하는 decoder가 거기에 연결하게 되면 계약을 통신하는 거죠. 그래서 저희가 버스 grant와 master에 대한 얘기를 분명히 말씀을 드렸지만 어떻게 동작을 하는 거냐면 기본적으로 버스 리페스트를 하잖아요. 버스 리페스트를 한다. 하게 되면 그럼 뭐 사이클은 우리가 라비트레이션의 로직에서 구현할 수 있다. 버스 리프스가 있을 때 이제 arbiter가 나름대로 뭔가 좀 고민을 해서 어떤 알고리즘을 돌려가지고 특정 어떤 master에다가 grant 신호를 주는 거죠.
23:39 grant 신호를 줬을 때 아직 사실은 이 버스에서 지금 동작하고 있는 어떤 다른 것들이 있을 수 있잖아요. 그러니까 아직은 버스에 대한 권리를 갖고 있는 건 아니고 그냥 네가 이 쿠레스 사례 중에서 제일 우선 수위가 높아 다음에 지금 현재 진행되는 게 끝나면 네가 버스를 사용하게 될 거야. 이렇게 arbiter 입장에서 보면 그래서 우리가 현재 진행되는 게 끝나는 거를 일단 어떻게 확인하느냐 일단 레디가 일단 하이가 되면 레드 하이가 되면 레드 하이가 되면 현재 게 일단 뭔가 끝났다라고 가정을 하는 거예요. 뭐 정확하게는 이게 현재 게 다 끝났다는 걸 얘기하진 않는데 일단 기본적으로 이걸 구성하는 게 어떻게 돼 있냐면 grant가 하이고 아비트로부터 구성할 때 에스터를 넘겨줄 때 grant가 하이고 레디가 하이가 되면 그렇게 되면은 두 번째 사이클에서 두 번째 사이클 그러니까 두 사이클로 짝짝 나눠서 생각한다 했죠.
24:37 그래서 이렇게 사이클을 두 사이클 딱 나눠서 생각할 때 grant가 특정 master grant 하이가 되고 그다음에 두 번째 사이클에서의 레디가 하이가 되면 그 조건이 제가 만족을 하면 master 신호를 받으겠습니다. 그래서 이제 그 AMBA에서 AMBA 스펙트를 보면 그렇게 써 있어요. 그런데 이제 우리가 사실은 이게 좀 약간 애매한데 뒤에 예가 나옵니다만 여기서 이 h range라는 건 사실 끝났다는 뜻이 된 건 맞거든요. 근데 이게 뭐 하여튼 엄밀하게 완벽하게 끝났다는 건 아닐 수 있어요. 왜냐하면, 우리가 이게 딜레이가 생기는 건데 우리가 뒤에 버스라고 얘기하는 게 있는데, 여기도 보시면 막 이게 계속 이게 계속 레이드가 되는데 만약 이제 뭐 여기 아직 안 끝난 게 예를 들어서 2개 이상이 있다. 딜레이가 되는 상황이다.
25:34 2개 이상이 딜레이가 되고 있었는데, 그 중에 하나가 끝났을 때도 여기 레드가 되거든요. 그렇다고 그러니까 얼마 전에 끝난 건 아니죠. 근데 하여튼 구분할 수 있는 방법이 없어요. 그래서 이제 일단은 아까도 얘기했지만은 암마에서 어떻게 얘기했냐면 일단은 request를 왔을 때 브랜드가 하이가 되고 일단 레드가 되면 일단 레스터는 바꾼다 그래놓고 실제로 데이터에 대한 실제로 권한은 그거는 이제 그냥 차례차례 순서대로 웨이트 되는 게 딜레이 된 게 있으면 걔네들 다 처리되고 나서 얘가 처리된다. 이렇게 결국 master라는 건 결국 뭐냐 여기 보시면 이 주소 주소 그다음에 여기는 없지만, 이제 보통 이제 그 hr 라인 이런 게 있거든요. hy 이게 이제 라잇일 때 1이고요. 그러면 라잇이 아닐 때는 1이라든 0이라든지.
26:28 신호 자체가 여기는 지금 정확한 표시는 없지만은 그 신호가 이제 그 신호를 말하자면, 이 신호 2라인하고 2라인 이 라인이 이제 결국은 여기 있을 때 이 주소가 바로 master 신호를 컨트롤하는 거죠. master가 되면 그때 주소하고 커맨드는 라인은 이제 이 hmaster에 있는 값으로 통신이 이루어지는 거죠. 데이터는 앞서 얘기했지만, 이게 완벽하게 여기서 다 끝난 거면 앞에 먼저 돼야 될 게 그럼 당연히 여기 데이터는 당연히 얘를 위한 공이 되겠죠. 저기 주소가 처음에 얘기했던 저는 데이터 보는 게 맞으니까 두 사이클로 봤을 때 그때 이제 완표가 끝나면 할 것만 끝나면 이제 그렇게 진행되는 게 맞고요. 근데 이제 뒤에 예를 보시면은 앞에 게 좀 오래 걸려서 끝날 수도 있어요.
27:22 뒤에 들리는 게 많으면 그러면 그때 가서 이제 그거는 차례차례 공식이 이루어지게 한다. 자 그래서 이제 좀 그렇게 동작하면 되는 거죠. 무슨 질문이 있나요? 그래서 여기 보시면 이게 보시면 되는 거고, 그래서 어 여기 이 얘가 그런 건데요. 자세히 보시면 말이죠. 여기 보시면은 일단 우리가 grant가 주어지면 이게 2로 그랜드로 옮겨가는 거죠. 1이 일단 사용하고 있었는데, 2로 grant를 옮긴다는 얘기가 돼 있고 그러면 얘가 하이인데 여기 보시면 일단 얘가 일단 이 사이클에서는 0이잖아요. 레드가 그러니까 여기서는 버스 계속 1한테 주고 있는 거죠.
28:21 그러다가 메디가 1이 되면 크리언트도 1이고 그러면 이때 이제 master가 hmaster가 2로 바뀝니다. 그런데 데이터 버스에서 어떤 일이 벌어지고 있었냐면 지금 이제 이게 지금 주소가 a+8이거든요. 그러면 여기 주소가 a+4였다고 칩시다. 사실은 근데 여기서 보면 원래는 원래는 이제 얘가 하이가 되면 하이가 됐다는 얘기는 사실은 마냐 마냐 예를 들어서 이게 좀 딜레이가 돼 가지고 얘가 a+4가 여기서 처리가 된다고 쳐봐요. 그럼 이 레디는 이거에 대한 게 끝났다는 거죠. 그럼 그다음에 사실은 얘가 파이가 되면 얘가 끝났다는 것이 될 텐데 불행하게도 얘도 또 레디가 0이야 그러니까 안 끝났다는 거죠. 그러면 언제든지 여기서 끝난다는 거죠. 그럼 얘 a 플러스 8에 대한 것이 여기서 끝난다는 얘기예요.
29:18 그런데 이미 아까도 말씀드렸지만 여기가 된 거죠. 그다음에 이제 acd까지가 들어가지 않습니까? 그러면 acd도 보니까 여기서 acv가 레디가 되면 좋을 텐데 안 돼 안 되고 얘가 또 어떤 이유로 여기서 해석이라도 딜레이가 생겨 그러면 얘가 acv가 여기서 끝나 근데 이미 아시다시피 버스는 여기를 넘어왔죠 2로 넘어왔죠 넘어왔는데 그래서 우리가 사실은 이 명령어 명령어하고 여기 주소 이건 이미 master2를 위한 주소 그러나 데이터는 앞서 있는 게 딜레이가 생겼기 때문에 아직은 a master 1이 했던 트랜잭션을 계속 하고 있는 거예요. 하고 있다가 이제 얘가 다 끝나고 나면 레드가 돼서 끝나고 나면 그때 가서 이제 데이터 b로 연결이 돼요. 그러니까 우리가 버스가 컨트롤한다는 것은 정확하게 얘기해서 명령어 그러니까 어떤 트랜스퍼한 종류거든요.
30:17 이런 논싱 컨트롤이라는 건데 뒤에서 말씀드릴 거고, 명령어하고 주소 이거를 누가 갖고 있느냐를 에스트라고 보면 알 수 있는 거죠. 데이터는 기본적으로 순서대로 처리가 되기 때문에 앞서 있는 게 밀려 있으면 버스 master가 바뀌었다. 하더라도 실제로 데이터 버스에서 동작하는 것은 앞서 있는 master와의 통신 결과가 있을 수 있다. 그거는 따져봐야 되는 거죠. 그래서 이제 우리가 결국 이 세 개는 같이 가야 되는 게 뭐고요. 데이터는 순서대로 설치된다. 물론 정확하게 이 그랜 링크레스가 있은 다음에 grant가 몇 사이클이고 이런 거는 스펙이 없어요.
31:05 저는 아비트와의 구결과가 달라지는 거니까 바로 그래도 리케스트가 나올 수 바로 grant가 나올 수도 있고 한 사이클 이따가 나올 수도 있고 두 사이클로 나올 수 있고 그런 건 정해지지 않고 AMBA스들이 정한 건 뭐냐면 그냥 master 값이 grant가 하위이고 레디가 하위가 되면 일단은 버스를 준다. master를 바꿈으로써 master의 값이 버스에 나타냈을 때 hmaster의 값이 들어갔을 때 걔와 일치되는 것은 주소하고 커멘트 라인드 데이터는 순서대로 처리된다. 이렇게 이해하시면 정확할 것 같습니다. 그래서 우리가 이제 일단 master 인터페이스를 생각해 보면 master 생각하는 건 일단 뭐가 있을 수 있냐면은 기본적으로는 이제 물론 이제 request하고 뉴캐스트를 아비토한테 주고 그다음에 이제 grant를 받겠죠.
32:02 grant를 받고 궁극적으로 arbiter가 사실은 먹스의 hmaster라는 걸 갖다가 세팅을 하겠죠. 그러면 이제 우리가 이 master를 어떻게 할 거냐 slave하고 통신하려고 그럴 때 몇 가지가 되는데 일단 주소를 줘야 되고요. 그다음에 그다음에 내가 이제 말하자면, 어떤 걸 할 거냐 hlit이라는 게 아까도 얘기했지만, 라잇 할 때 1이고 위드할 때 0이거든요. 이게 기본적인 명령어인데 h 트랜스라는 거는 뒤에 나옵니다마는 이제 뭐 그 그런 종류가 되겠어요. 시퀀스 논 시퀀스 이런 게 돼 있고 그다음에 이제 이 버스라는 게 나중에 나오는데 버스라는 건 뭐냐면 기본적인 아이디어는 원래 이제 메모리라는 메모리 같은 경우에는 순차적으로 접근하는 경우가 많잖아요.
32:57 그랬을 때 사실은 기본적으로는 이제 어 첫 번째 아이템 데이터 에드레스 준 다음에 그다음에 데이터 그다음에 그다음 데이터 그다음 데이터 이런 식으로 쭉 한번 시작 주소로부터 일정한 간격을 두고 여러 가지 데이터를 계속 액세스할 때 그럴 때는 버스의 종류가 되겠습니다. 그다음에 이제 할 때 엑사이즈라는 건 당연히 한 바이트를 읽을지 두 바이트를 읽을지 4바이트를 읽을지 이런 걸 결정하는 것이 엑스 사이즈가 되겠습니다. 기본적으로 여기 얘가 얘기하고 싶은 건 메서 주는 건 일단 주소하고 명령어예요. 어떤 통신을 할 것이냐를 주게 되면 얘를 갖다가 이제 우리가 리코더를 통해서 이제 얘가 슬랩을 선택하게 되고 하게 되겠죠.
33:48 기본적으로는 에드레센 컨트롤 에듀레센 컨트롤이라고도 하고 에듀레센 커맨드라고도 하기도 하고 그런 것들은 기본적으로는 전달이 되면 그러면 slave 입장에서 보면 물론 라이스인 경우에는 데이터도 가야 되겠죠. 데이터를 라이트 데이터 라잇 데이터 그러니까 AMBA에서 전해주는 것 중에 하나는 위드하고 라잇을 하는 걸 갖다가 1달 때 하고 라이트할 때 하고 그러니까 방향상으로 보면 master가 있지만 결과적으로 master가 데이터를 제공하는 게 라이즈고 slave가 데이터를 제공하는 게 위드잖아요. master 입장에서 얘기하는 거니까 우리가 별도의 채널을 두게 돼 있습니다. 그래서 우리가 위드 채널과 라이즈 채널을 별도로 두게 돼 있죠. 이것도 역시 이건 온칩이기 때문에 그래요. 우리가 오프 측으로 가게 되면 물론 리드할 때 라이트 할 때에 별도의 라인을 둔다는 건 상상하기가 쉽지 않아요.
34:47 항상 이게 어떻게 오프칩으로 가게 되면 당연히 데이터 라인은 하나입니다. 그거 가지고 바이디렉션하게 쓰는데 온 칩이니까. 칩 아니니까 사실은 뭐 공간이 여유가 있다고 보는 거죠. 그리고 거리도 되게 짧고 그렇기 때문에 당연히 이거는 별도의 신호를 그래서 우리가 이제 그 라잇 데이터를 위한 버스를 우리가 hw 그러니까 h라는 것은 ahb에 대한 모든 거에 들어가는 거고요. 그다음에 이제 apb라는 버스가 있는데, 그건 p가 들어갑니다. 그리고 그다음에 w라잇이고 데이터 버스 이렇게 그래서 이렇게 데이터가 가게 되고요. 그다음에 선택을 하게 되고 우리가 그러면 slave 입장에서 보면 slave는 몇 가지의 데이터를 주게 되는데 하나는 잘 끝났다 이게 랩입니다.
35:38 에이치 레이 뭔가 내가 위대하라 위대하라 그러면 그럼 내가 두 번째 사이클 그러니까 첫 번째 사이클을 완드레스하고 커맨드를 받아서 그게 믿으면 두 번째 사이클 끝나기 전까지 내가 데이터 버스에다가 네가 원하는 데이터를 올려놨어 이렇게 되는 거죠. 그러면 h 레디가 1이 되는 거죠. 0이면 당연히 아 내가 느려가지고 두 번째 사이트 끝날 때까지 어 사실은 못 올려놨어 다음 사이클을 좀 기다려봐 알겠냐는 거죠. 그래서 이게 일이라는 건 잘 끝났다는 거고, 레디라는 측면에서 준비돼 있다. 이런 뜻인데 다음 번 트랜잭션 할 수 있는 준비가 됐다. 이런 뜻으로 이해하시면 돼요. 하여튼 레드라는 뜻을 쓰게 되고 그리고 이제 리스폰스라는 거는 사실은 이제 아무 문제 없을 때 오케이 그다음에 에러가 있을 때 에러 전에 제가 얘기했는지 모르겠지만, 스플릿 트랜잭션이라는 게 있죠. 미트라이라는 게 있어요.
36:34 뒤에 나오니까 이야기하지만 하여튼 기본적으로 특히 에러가 있거나 아니면 오케이 두 경우가 있겠죠. 그러니까 에러의 측면을 생각하시면 안 돼요. 에러라는 건 정말 문제가 있어서 여러분 다시 보는 사람들이고 다시 시작하라는 얘기고 그다음에 기본적으로 이 ok라는 거는 큰 문제는 없는 거죠. 다만 h를 0이라는 거는 지금 못 끝냈다는 거지만 이게 오류는 아니죠. 그러니까 웨이트 정도가 되는 거니까 그래서 우리가 보통은 이제 뭐 hread가 0이다. 그래도 이 risp 리스폰스는 ok가 되는 경우가 그러면 당연히 이건 오케이가 되겠군요. 에러가 있는 경우 스플릿 리트라이 이런 게 있는데, 이 모든 게 다시 한번 얘기하지만 그냥 AMBA에서 얘기하는 프로토콜이에요.
37:33 그러니까 이걸 뭐 딱 이렇게 해라 라는 게 아니라 뭐 물론 당연히 이제 우리가 뭐 프로세서 따로 있고 뭐 슬레임 따로 만들고 하니까 어느 정도 이 프로토콜 지켜주는 게 좋겠지만, 얘는 내 집안일이잖아요. 집안일 이거를 어떻게 정의하고 어떻게 사용하느냐는 정확한 구현은 사실은 버스 설계자가 정합니다. 뭐 이렇게 뭐 취가 아닌 일이니까. 뭐 이렇게 얘기하지만 하여튼 이렇게 4가지 옵션을 생각해 만들어 놓고 하여튼 통신을 하게 되는 거고, 당연히 이제 여기 에이치알 데이터 미드 데이터죠 그러니까 당연히 위드할 때는 매스 slave도 데이터가 와야 되니까. 그래서 크게 봤을 때 slave는 세 가지의 어떤 종류의 이걸 하게 되는데 끝났다 안 끝났다 그다음에 에러가 있다. 없다. 그다음에 네가 원하는 데이터가 오고 세 가지를 슬레이드가 주게 됩니다.
38:31 선택을 하는 건 기본으로 하다 보시면 될 것 같고요. 그게 전부에요. 다시 한번 얘기하지만 사실 여러분이 버스 설계를 여러분이 아마 안 할 것 같아요. 아마도 아마 기본적으로는 아마 여러분이 그냥 원래 징크라고 하는 fga 보도를 쓰는 걸로 알고 있는데, 정확하게 모르겠는데 뭘 부스는 모르겠는데 프로젝트를 쓰는데 그 징크라는 보드 자체는 사실은 이렇게 암 프로세서가 이미 있고요. 방금 그다음에 여기 fga가 있는 거죠. 얘를 이제 얘를 갖다가 이미 다 안 박을수록 연결을 받았어요. 이미 안 박았어. 이걸 이제 우리가 징크보드라고 하는 게 있는데, 이걸 쓰는지 아직 잘 모르겠어요. 여기서 하여튼 이런 걸 쓴다고 하면 얘는 이미 안 붙으니까 이미 얘하고 얘가 이미 있기 때문에 여러분이 여기에다가 로직만 만들어서 동작시키는 걸로 할 것 같아요.
39:30 버스를 설계할 필요는 없겠지만, 하여튼 여러분이 soc를 한다 그러면은 사실 뭔가 이 취발 특히 디지털 soc를 한다. 그렇다는 얘기는 취발에서 이제 여러 가지 모듈이 들어가는데 얘를 연결할 때 이제 버스를 사용하게 되면 이걸 설계하게 되는데 이때 이제 hb 정보를 가지고 하면 대부분 설계가 끝납니다. 여러분 뭐 그 이상을 하려고 그러면 정말 저는 전무라도 회사 가서 어 정말 soc 하는 회사로 가서 해야 되는 건데 생각보다 그렇게까지 삼성이나 뭐 아주 일부 대기업 lg나 대기업 가지 않고서는 여러분이 일반적인 회사를 가면 우리나라가 사실 디지털 쪽이 이렇게 아주 강하지가 않기 때문에 그냥 간단한 이렇게 ah 버스 정도만 만들어도 충분히 원하는 어떤 수비 양상이 됩니다. 별로 복잡하진 않죠 그래서 이제 우리가 이건 decoder가 되겠고요.
40:27 decoder는 아까도 얘기했지만, 주소를 받아가지고, 주소를 받아가지고, 두 가지를 주는데 하나는 실제로 칩 슬랙트를 하는 거죠. 100 이런 식으로 가가지고 특정 slave 슬랙트 하고 그리고 슬랙트 넘버가 0 1 2 3이라고 치면 여기 0 0 이런 식으로 슬레이프 이거는 이제 얘는 먹스로 가는 거죠. 먹스 얘는 실제로 slave로 가는 거예요. h slave로 가는 게 제가 그림 아까도 얘기했지만, 저 그림에서 슬래버 아닙니까 디코너가 주소를 받아 가지고 h 슬랙트라는 게 어떤 slave를 선택하는 거고, 그와 동시에 slave 넘버를 h 슬랩을 넣어주게 되면 그런 겁니다. 기본적으로 그렇게 이해하시면 될 것 같고요.
41:26 어려운 얘기는 아니죠. arbiter의 경우에는 사실은 뭐 우리가 AMBA에서 정확하게 어떤 로직을 가지고 해라 라는 얘기가 없어요. 그럼 그냥 네가 만들어서 알아서 써라 니 네 취업은 네가 아는 거니까 어떤 슬라이드한테 어떤 우선순위를 줄 거냐 이런 것들은 사실은 뭐 아미터가 정해주는 게 아니라 그냥 내가 알아서 해라 이렇게 하는 거죠. 어떤 fixed 프라이어티 아비트레이션이 있다고 가정합시다. 보통 우리가 뭐 예를 들어서 우리가 0번 slave가 0번 1번 2번 3번 있다고 치면 얘는 우선순위를 높게 본다거나 이렇게 한다는 거죠. 그러면 동시에 리프레스를 받았을 때 프라이어티에 의해서 말하자면, 하나를 주는 겁니다. 그러니까 이걸 우리가 기본적으로 앞에서 벨로 배울 때 프라이어트 인코더라고. 했었던 거죠. 프라이언트 인코더 우리가 동시에 어떤 입력이 부를 때 예를 들어 제가 그런 얘기 했었잖아요.
42:21 우리가 게임하는 거 무슨 뭐 밥 먹는 거 잠자는 거 soc 공부하는 게 있는데, 동시에 느껴서 들어오면 게임하는 게 이제 무조건 소수가 높으면 들어가는 거죠. 비슷하게 그래서 사실은 클라이언트 인코더 그리고 이게 사실은 그래서 뭐 굳이 얘기하자면 결국 arbiter와에서 쓰는 로직하고 똑같아요. 아비트레이션 로직하고 프라이언트 모코너 하고 사실은 여러분이 중간고사에서 되게 요상한 문제 뭐 이렇게 있었잖아요. 뭐 있었어요. 베를로가 라인 하나 썼어주고 이거 회로로 그려라 모르겠지만, 그런 것도 있었는데, 그게 답이 프라이언트 인코더고요. 실제로 그게 다이 프라이즈 인코더였고 그다음에 그게 어디 쓰이냐 하면 실제로 보면 이제 버스 아비트레이션에 쓰이는 모습이 나왔습니다. 거의 결국 제가 요구한다면, 프라이드 인코너가 맞고요.
43:16 중간고사에서 그리고 사실은 아비트를 위해서 쓴 로직이다 라고 써도 아마 정답 처리했을 거고, 똑같은 얘기니까 지금 제가 보다 그렇게 얘기를 하시면 될 것 같고, 이해하시면 될 것 같고, 그래서 어떤 로직에 따라서 그랜드를 주는 거죠. 그래프를 주고 그다음에 약간의 딜레이 여기 이제 여기 렉이라는 거는 이제 우리가 얘는 기본적으로 막혀 있다가 클럭이 이제 올 때마다 딜레이가 생기는 거거든요. 바로 나타나 바로 어떤 값이 보이면 바로 보이는 거고, 바로 버스 브랜트가 나타나는데 실제 master는 현재 아까도 얘기했지만, 레디가 일단 1이 되고 나서 그때 가서 master 값이 딜레이 뭐 렉이라는 게 기본적으로 한 사이클 딜레이겠지만, 여러 사이즈 딜레이가 있을 수 있는 거죠. 그래가지고 얘가 얘를 막고 있다가 막고 있다가 이제 어떤 이 조건이 완성이 되면 그때 가서 얘가 딱 클럽을 집어넣어 가지고 얘가 들어가는 순간 여기에 이제 이런 master 값이 세팅이 됩니다.
44:19 뭐 그렇게 되는 거고, 아니 여기에는 이거는 그거군요. 제가 이제 그게 아니라 여기서 얘기하고 싶은 거는 그게 아니라 기본적으로는 이제 grant가 있고 master master 나름대로 로직에서 나오는데 이거는 뭐냐면 아까도 얘기했던 데이터 쪽 데이터 쪽에 딜레이 이렇게 하나 놓는다 그랬잖아요. 데이터 버스는 주소와 커뮤니가 아니라 한참 있다. 나타날 수 있기 때문에 그 딜레이를 그 딜레이 이제 보면 이제 라잇 데이터 워크스로 간다 이렇게 돼 있잖아요.
44:58 라이트 데이터 워크스 그리고 기본적으로는 아무 딜레이가 없더라도 일단 주소와 아이고 주소와 커맨드가 여기서 가고 그 다음에 데이터는 여기서 가야 되는 게 컨트롤과 에드레스 벅스를 위해서는 마스터가 바로 가는 게 맞고 데이터 라잇 데이터 먹스를 위해서는 한 사이클 딜레이가 추적을 가요 뭐 앞에 게 안 끝났다 이것도 더 만들어야 되겠지만, 일단 그게 없더라도 앞에 게 깔끔하게 끝나서 지금 내 거 지금 한다 하더라도 라인데이트하고 억셀은 한 사이클 딜레이가 일단 다행이다. 그 얘기를 하고 있는 게 바로 이 hmasca 딜레이가 되겠습니다. 뭐 이거는 이제 우리가 뭐 별건 아니고 윙슈트라는 게 이런 거예요. 이렇게 봤을 때 이렇게 이렇게 있으면 링을 돌리면 얘가 이런 식으로 바뀔 거 아니에요. 각도 바뀌면 이런 식으로 이렇게 바뀌겠죠.
45:56 이런 식으로 이걸 이제 우리가 이걸 라우드 로빈이라고 하죠. 아 이렇게 공평하게 공평하게 이렇게 윙으로 만들어 버리면 1이 되는 애가 벌써 사용하는 거지 그럼 얘는 어떤 우선순위를 주는 게 아니라 그냥 공평하게 되게 공평하게 사이좋게 한 번에 돌아가면서 쓰는 어떤 그런 개념들을 이용식으로 해놓은 거고요. 이거는 뭐 이거는 뭐 우리가 뭐 이렇게 안 해도 되는 거죠. 이건 알아서 쓰면 되는 거니까 약자는 그렇게 중요한 건 아닙니다. 이게 지금 라운드 우리 이렇게 쓴 게 이걸 갖다가 이제 이런 모직이 안 만들어지려면 이거 어떻게 하면 된다는 거죠. 그래서 결론적으로 얘기하면 이건 뭐다라고 얘기해서 저희가 master 인터페이스를 설계한다는 거는 결국은 master는 두 가지 아비토하고 통신을 일단 해야 되고요. 그다음에 slave하고 통신합니다.
46:55 얘도 slave도 보면 결국은 이제 일반적으로는 master 쪽으로 통신한다고 생각하면 되는데 이제 우리가 뒤에 얘기할 때 스플릿이라는 게 있거든요. 스플릿 같은 거는 뭐냐 하면 내가 주소하고 커멘드를 받았어. 그랬는데 내가 지금 그거를 끝낼 수가 없는데 그냥 한 사이클 두 사이클 기다리는 건 그냥 h 웨드를 0으로 만드는 거예요. 그러면 기다리게 해주는데 그 정도가 아니야. 지금 뭔가 뭐 한참 못 끝나 한참 기다려요 그러면 어떻게 하냐면은 스플릿이라는 걸 날리거든요. 그게 무슨 얘기냐면 arbiter한테 야 버스를 지금 master로부터 뺏어가내보자 나중에 내가 끝나면 다시 전송할 테니까.
47:44 지금은 내가 끝낼 수가 없으니까 그래서 우리가 보통은 이제 스플릿이라는 게 쪼개다는 뜻인데 에드레스와 커맨드가 있으면 데이터가 왔다 갔다 하는 기기들이 하나의 트랜텍션인데 이를 쪼개다는 거죠. 그러면 이제 우리가 얘를 못 끝낼 것 같으면 이 slave가 스플릿 케이퍼블 하는 slave라고 치면 얘를 얘를 갖다 누구한테 주냐면은 아비타한테 주고 일단 버스를 뺏어서 뺏어서 일단은 나중에 끝나면 다시 달려 아직 알려줄게 알려줄 테니까. 그때까지는 현재 master로부터 뺏어서 다른 애를 줘라 다른 애가 좋아 이런 얘기를 하는 게 되겠고 나머지는 기본적으로는 일단 master로부터 오는 신호 master로부터 가는 신호가 되겠죠. 색깔이 달라지는 건 인풋 아웃풋 정도만 차이가 좀 있는 거고요. 기본적으로 뭐 이렇게 중요한 의미는 아니고요.
48:39 그래서 아까도 얘기했지만, 이제 슬레이블은 간단한 거죠. rad 끝났다 안 끝났다 그다음에 에러가 있다. 없다. 오케이냐 에러냐 기본적으로 스플릿도 거의 들어가지만 그다음에 세 번째는 위드할 때는 데이터를 주는 거 그다음에 master는 마이크 할 때 데이터를 주는 거 그다음에 클럭 신호 그다음에 예를 들어서 주소하고 어떤 통신을 할 거냐 커맨드 컨트롤 신호 그래서 결론적으로 시험이 뭐가 나오느냐 잠깐만 볼게요 시험에는 이런 게 나와요. 이런 정도의 변화가 나오고 나서 뭔가 조건이 주어지죠 주고 어떤 거에 대한 걸 빈칸으로 만들어요.
49:35 어떤 조건을 바탕으로 해서 채워라 여기 보시면 이제 여기 이게 주소가 되는 거잖아요. 주소 이 주소에 대한 데이터가 되어 있는 거잖아요. 그러면 이제 어떤 다른 신호가 주어졌을 때 이 주소에 대한 데이터가 어디 나타나는지 표시하라든가 그런 신호 문자가 나올 것 그런 게 나올 거고, 여기 프로토콜을 뭐 어차피 오픈 노트니까 뭐 외울 것도 없구요. 여러분이 그냥 이해를 할 수 있느냐가 중요한 겁니다. 그래서 이제 우리가 그 AMBA에 대해서 거의 뭐 얘기를 다 했고요. 얘만 쭉 보면 되겠어요. 보면 될 건데 일단은 이제 제일 중요한 신호 중에 하나는 hl입니다. 에이트레디는 프롬 slave죠 slave에서 만들어지는 아주 중요한 신호가 되겠고 결국은 액티브 하이 2개가 하이일 때 그러니까 우리가 신호 중에 n이 끝에 안 붙으면 여기 n이 붙으면 이건 액티브 로우예요.
50:31 액티브 로우라는 얘기는 요 여기의 의미가 그다음에 0일 때 그 의미가 추가되는 거죠. 근데 액티파이라는 건 n이 안 붙는 거니까 얘가 1일 때 1일 때 이 의미가 되는 거죠. 레디가 출가되는 거죠. 잘 끝났다 이런 얘기가 그래서 일단은 우리가 이게 제일 중요하고요. 제일 중요합니다. 그래서 이제 우리가 봤을 때 그러면 이제 우리가 기본적으로 h 클럭은 클럭시모가 되겠고요. 리셋은 리셋할 때 있는 거고, 이게 nft니까 0일 때 리셋이 되겠죠. 그다음에 hatdr은 주소가 되겠고 트랜스라는 것도 역시 이제 우리가 방법이 되겠는데 이 트랜잭션의 어떤 트랜스포텀 트랜잭션이라는 뜻인데 이제 이게 논 시퀀셜 시퀀셜 아이들 비즈 이 네 가지가 있어요. 여기서 이제 우리가 아이들이라는 건 아무것도 안 보라는 뜻이에요. 베스토가 뭐 아무것도 안 보낼 수 있는 거죠.
51:30 버스는 갖고 있으되 아무 통신을 지금 하지 않아 그럼 아이들이 되겠죠. 아니면 아니면 두 가지를 하게 되는데 기본적으로는 아 우리가 그 non sequential이라고 얘기하는 거는 그러니까 이제 이 sequence를 얘기하면 되는 거죠. 아까 우리가 verse라는 걸 얘기를 했을 때 verse가 뭐였냐면 어떤 시작 애들에서부터 같은 이제 어떤 일정 간격을 둔 데이터가 쭉 가는 거죠. 얘가 주소가 100이라면 104번 데이터 108번 데이터 112번 데이터 데이터 데이터 데이터가 되는 거고, 기본적으로는 주소를 하나만 주면 얘가 플러스 4 플러스 4 플러스 4 해 가지고 쭉 엑셀 싸우면 되죠. 물론 조금 더 디테일하게 말씀드리면, ahb는 근데 아직은 멀스 하더라도 ahb 자체는 이 실제로 주소를 이렇게 주게 돼 있어요. 사실은 주소도 되게 돼 있는데, 꼭 필요는 없는데 아 주소를 주게 돼 있어요.
52:28 되겠고 이 다음 버전에 axi라는 버스가 있는데, x버스라고 얘는 사실은 얘는 줄 필요 없습니다. 첫 번째만 주면 되고 그래서 항상 주소 하나만 딱 주고 그다음에는 없으면 그냥 뭐 어떤 플러스 사프로 이렇게 데이터가 계속 오는 거죠. 데이터 분석이 있는데, 뭐 차이는 있나 일단 그것은 아주 중요한 건 아니니까 일단 aatp를 할 때 주소는 주긴 주되 일정 간격으로 일정 간격으로 이렇게 쭉 연결되는데 이걸 버스라고 하는데 그때 처음 시작은 사실 이제 버스 시작이니까. 이게 이제 넌 시퀀스가 되는 거고요. 그리고 얘네들은 그 다음부터 하나 시퀀스가 되는 거죠. 그러니까 버스트의 시작은 논 시퀀스가 되는 거고, 또는 버스가 아니면 돼 넌 시퀀스가 되겠죠. 무조건 그렇게 안 하는 거니까 근데 이제 우리가 시퀀스라고 얘기하는 거는 버스트의 두 번째부터 쭉 연결되는 그런 것들이 이제 시퀀스가 되겠고 이게 이제 논 시퀀스와 시퀀스예요.
53:28 근데 그럼 비즈는 뭐냐 아이들은 아무것도 안 하는 거고요. 아무것도 안하는 거고, 비즈는 시퀀스에서만 의미가 있어요. 시퀀스에서 원래 시퀀스는 이렇게 매사이클 하나씩 착착 돼 있다가 있잖아요. 그런데 어떤 이유로 인해서 master가 다음 데이터를 주거나 받거나 이걸 못하는 경우가 있을 수 있잖아요. 시퀀스에서 넌 시퀀스로 시작을 해서 얘가 시퀀스 시퀀스 이렇게 매사이클을 뭐 주소를 가지고 가야 되는데 갑자기 얘가 시퀀스를 여기서 가야 되는데 얘가 지금 시퀀스를 못할 입장이야 그럼 여기서 master가 비지션을 실어내는 거예요. 얘가 이제 약간 말하자면, master 쪽에서 딜레이를 넣는 거예요. 딜레이 넌 시퀀스는 아예 그냥 시작을 안 하는 거니까 그냥 그건 아이들이에요.
54:19 아이들이 되는 거고, 다시 말해서 시퀀스 버스트로 해서 메세지 하나씩 착착 데이터를 주고받는 상황에서 master가 어떤 의미일까요? h 레디는 slave가 내가 못 끝냈다는 뜻이잖아요. slave가 근데 비즈는 뭐냐면은 버스트 중에 버스트 중에 내가 내 사이클을 뭔가 착착 진행하기 위해서 시퀀스를 해야 되는데 그때 내가 뭔가 못 끊는다 뭔가 좀 딜레이를 넣는 약간 딜레이를 넣는 개념으로 쓰는 게 바로 빚입니다. 그래서 우리가 네 가지를 묶어서 두 비트로 먼 시퀀스 시퀀스 현재 진행되고 있는 트랜스퍼의 종류를 표시하게 돼 있습니다. 당연히 이것은 맥스에서 올릴 수밖에 없죠 그다음에 이제 우리가 계속 매스트도 그렇지만 h 라이드 이건 우리가 아니지만, 하이일 때 라이스 되는 거고, 로일 때 리드가 되는 겁니다.
55:16 그냥 하면 되겠고 사이즈는 이제 우리가 아까도 이런 버스가 데이터 버스가 정확하게 32부터 뭐, 뭐 256까지 되어 있는 것뿐 아니라 뿐 아니라 사실은 이제 뭐 한 바이트를 읽을 수도 있는 거잖아요. 한지 비트를 가지고 왜냐하면, 로드 바이트 이런 게 있을 수 있거든요. 로드 해프워드 이런 게 우리 두 바이트를 읽어요. 보통 로드 워드 이러면 4바이트를 들어오는 거니까 사이즈를 우리가 기본적으로는 8비트 즉 8비트 1바이트부터 그다음에 2바이트 4바이트부터 쭉 해서 사실은 1024비트 그러니까 말하자면, 이게 10층이니까. 8승 바이트까지 맞습니까? 1보수 있나요? 그리고 1보수 하여튼 그렇게 얘는 사이즈를 통해서 이렇게 되는 거죠. 그러니까 이건 뭐 큰 의미는 없고 이렇게 생각하시면 돼요. 그러니까 예를 들어서 우리가 이게 이제 3비트잖아요. 3비트 000부터 112 이렇게 3개가 있을 거 아니에요.
56:15 3비트니까 그게 이제 000이 2의 3승이구요. 그러면 이게 플러스 7을 하면 이게 나오니까 2의 10승까지 나오는 거죠. 2의 8비트부터 2의 10승 b까지 이렇게 할 수 있는 거죠. maximum에서 1024비트라는 게 이렇게 나온 겁니다. 그래서 이런 것들이 우리가 h 사이즈가 3비트고 000이 8비트고 그다음에 2의 10승 1024비트 맥스 파이사비트까지 할 수 있는 거죠. 그렇게 되고요.
56:52 그 다음에 이제 우리가 그 말하자면, h birth라는 게 아까 얘기했지만, 그건데 이 verse가 이제 시험도 잘 나오고 사실은 좀 헷갈릴 수 있는 여부가 있는데, 결국 verse라는 것은 하나의 주소로부터 시작해서 몇 개의 데이터를 보내느냐거든요. 몇 개의 데이터를 우리가 할 때 이걸 비트가 아니라 비트라고 부릅니다. 그래서 for b cap6b 되어 있어요. 그러니까 for 비트라고 얘기하는 거는 하나의 주소로부터 시작해서 데이터 데이터 데이터 데이터 데이터 데이터 간다는 거고요. 당연히 apit는 여기서 데이터를 멜러스가 알렉스가 나온다는 얘기겠죠. 버렸어요. 그런 것처럼 그런데 이제 우리가 이게 이제 여기 보시면은 이게 세 세 비트잖아요. 2 땡땡 0이잖아요. 3비트잖아요. 8가지 조합이 있어요.
57:52 뭐가 있냐면 뒤에 나옵니다만 벌스트가 아닌 경우가 있을 수 있지 당연히 버스트가 아닌 경우에 그다음에 버스트가 있을 경우에는 이 세 가지가 있잖아요. 세 가지가 있는데, 벌스 4인 경우에는 그런데 얘가 두 가지 타입의 버스트가 있어요. 구매 타입이 있어가지고 우리가 부의 타입이 있고요. 여기 보면 이제 맵이라는 게 있고 그냥 인클랜팅이 있는데, 그러고 나서 그냥 그다음에 무한대로 귀속되는 이런 것도 있을 수 있어요. 대충 8가지 조합이 나와요. 근데 여러분이 헷갈리는 건 뭐냐면 바로 랩핑 버스트라는 건데 랩핑 버스트의 특징은 뭐냐면 그러니까 버스라는 게 데이터가 쭉 어떤 그 주소가 이렇게 잉크미크 가는 건데 랩이라는 건 뭐야? 이렇게 뭔가 싸는 거잖아요. 랩핑 버스는 뭐냐면 이렇게 되는 거예요.
58:47 여기서 만약에 보다 시작할 필요 없죠 여기서 데이터를 가다가 주소가 어떤 바운더리를 만나면 일로 가는 게 아니라 여기서부터 사실 이와 같다 그러니까 쭉 가는 걸 인크리멘팅이라고 얘기하는 거고, 인크리멘팅 그리고 어느 바운더리에 가게 되면 데이터의 주소가 다시 오히려 앞으로 오는 이걸 갖다가 우리가 랩핑 것이죠. 이렇게 해서 버스 그러니까 무한정 하는 거하고 안 하는 거 하고 이 6가지 조합 이렇게 8가지 이렇게 버스 종류가 나와요. 근데 랩핑하는 이게 헷갈리는 부분이거든요. 랩핑하는 부분이라면 되게 질문이 많은 것 중에 하나입니다.
59:44 어떤 어떤 주소를 가지고 어디서 랩핑이 이루어지는지 그러니까 내가 계속 다음 주를 연결해서 가는 게 맞는지 아니면 어느 바운드에 가서 맵핑이 돼야 되는지 일단 여러분이 많은 질문이 있기 때문에 그걸 제가 좀 이따 자세히 설명을 드릴게요. 프로젝션은 우리가 많이 안 씁니다. 어떤 메모리의 보호적인 측면에서 쓰는 건데 이건 우리가 이 수업에서는 거의 다루지 않겠습니다. 그다음에 이제 w 데이터라는 건 당연히 라이트 데이터니까 master부터 다른 거죠. 그다음에 h 슬라이드라는 걸 decoder에서 나오는 특정 slave를 선택하는 그런 신호가 되겠습니다. 미드 데이터 당연히 이거는 슬라이브에서 오는 거죠. 미드 데이터니까 라인 데이터와 리드 데이터 분리되어 있습니다.
01:00:39 그다음에 hdled가 끝났다는 뜻이고 그래서 transpor가 heaspinet이 끝났다 이런 걸 얘기해주는 거고, low라는 거는 익스텐드 즉 약간 웨이트 시너십으로 되어 있죠. 그러니까 아직도 스테이터스 오케이에요. 에러는 아닙니다. 이게 이 자체가 에러는 아니에요. 그냥 우리가 ok인데 들리는 시간을 기다려라 다음 사이트 그래 끝났는지 한번 확인해 볼게 이렇게 되는 거죠. 그래서 놓을 때 트랜스퍼레이트 된다는 거고요. 그다음에 그다음에 이게 리스폰스가 되는데 리스폰스가 아니고 ok 에러 비트라이 스플릿이 되는 거죠. 이렇게 얘기하시면 될 것 같습니다. 그다음에 이제 우리가 다른 것들 말고 여기저기 인큐멘티브 랩핑인데요. 이 얘기를 좀 합시다.
01:01:35 그래서 이제 우리가 티피컬 트랜스포라는 것은 일단 트랜스퍼 하기 전에 당연히 master가 당연히 버스를 일단 grant를 받아야 되는 거죠. 그리고 arbiter가 hmanster라고 하는 에스터 라인을 갖다가 버스에다가 h 마스터 라인에다가 어떤 측정 번호를 주면 걔가 이제 실제로 거기에 주소하고 명령어를 얹혀놓게 되면 현재 트랜스퍼가 이루어집니다. ok하고 레드가 있는데, ok랑은 문제 없다는 건 에러는 다시 에러가 있으니까 다시 보내듯이 뭐 하여튼 뭔가 문제가 있다. 이렇게 하는 얘기고 리트라이하고 스플릿이 있는데요. 스플릿 아까 좀 더 설명을 드렸죠 리트라이하고 스플릿은 사실 미묘한 차이가 있어요. 리트라이하고 스플릿은 뭐냐면 아 기본적으로 둘 다 공통적인 건 뭐냐면 일단 주소하고 커맨드가 오는 게 첫 번째 사이클이구요. 두 번째 사이클에 데이터가 오는 게 맞죠. 근데 얘를 자르는 건 맞아요.
01:02:33 자르는 의미에서 보면 사실은 이제 결국은 이걸 갖다가 말하자면, 우리가 slave가 arbiter한테 야 현재 지금 master로부터 버스를 뺏어 버스를 빼서 벗으라는 얘긴데 알려주는 거거든요. 못 끝내 지금 나는 지금 다른 거에 대해서 안 돼 이렇게 얘기인데 그럼 리트라이하고 스플릿 똑같아요. 똑같이 일단 버스를 빼서 이렇게 얘기하는 건 똑같은데, 차이가 뭐냐면 우리가 이게 안 받았으니까 정한 거니까 그러면 이제 우리가 얘가 master라이즈에서 한 3개 있다고 칩시다. 3개가 있으면 그럼 이제 arbiter가 버스 제 레스터 제로를 쓰고 있었어요. 그럼 얘를 뺐겠지 뺐죠 그럼 뺏었다는 얘기는 뭘 의미하냐면 그러면은 다른 애들로부터 리프레스를 받는 거예요.
01:03:27 버스 이제 너희한테 뺏을 거니까 버스 사용할 사람 로켓을 받을 거 아닙니까 그럴 때 스플릿이 되면 스플릿이 오면 이 master 제로는 아예 리프레스트를 받지 않습니다. 제외되는 거예요. 그러니까 이 스플릿을 친 slave가 뭔가 다시 통신을 재개할 수 있어 라고 알려주기 전까지는 master 제로는 더 이상 버스의 리프레스를 받지 않는 거고요. 위트라이는 일단은 뺐는데 베스트 제로부터의 로켓을 또 받는 거예요. 차이 아시겠죠. 위트라이라는 말 자체가 다시 시도해라 이런 뜻이니까. 어떤 의미로 하여튼 내가 버스를 일단 뺐긴 뺐는데 하지만 위트라이 다시 트라이를 기회를 주는 거죠.
01:04:17 그래가지고 위트라인 경우에는 거기서 master 제도를 뺐지만 다시 리프레스트를 모든 master부터 받는 거고요. 스플릿은 일단은 뺏은 어떤 그 master는 일단은 리프레스트 받는 걸 차단시켜버려요 그런 미묘한 차이가 있습니다. 그래서 그게 말하자면, 리스폰스라고 하는 말하자면, slave에서 오는 신호가 되는 거고, 기본적으로 이 두 개는 그래서 결국 버튼을 주고 뺏고 하는 거 잊지 말고 주고 평가를 하는 거기 때문에 기본적으로는 얘는 이렇게 아비토한테 가는 거고요. 기본적으로 얘가 이제 기본적으로 버스 master나 이런 데 알려주는 거죠. 문제없다. 문제 있었다. 이렇게 되는 거죠. 차이가 있는 게 리스폰스 신호단 그래서 이제 얘를 쭉 볼 건데요.
01:05:15 앞으로 얘기했던 얘기들 한번 이런 타이밍으로 볼 건데 기본이 이렇다는 얘기예요. 기본이 그래서 우리가 이거는 그 라이트하고 위드를 한꺼번에 표시한 거예요. 동시에 일어나는 건 아니지만, 그러니까 얘는 공통이고 그다음 얘도 공통이죠. 그리고 이제 우리가 라이트 할 때는 이렇게 보셔야 되고 미드할 때는 이것 빼기고 얘를 보셔야 돼요. 미드하고 라잇을 한꺼번에 그냥 지나지 않습니다. 동시에 이렇게 미드라이즈가 이루어진다는 게 아니라 기본적으로는 공통인 게 대부분이기 때문에 뒤에 나오는 모든 그림에 이제 라이트 할 때는 이걸 보셔야 되고 미드할 때는 이걸 보시면 됩니다. 근데 하여튼 기본적으로는 기본적인 게 똑같은 게 뭐냐면 첫 번째 사이클에 애드레스페이스라고 하죠. 그래서 주소와 어떤 아까 어떤 통신을 할지 리날드 라이트 할지 또는 아까 트랜스가 얘기했죠. 시퀀스 논 시퀀스 있었잖아요. 버스도 있고 이런 게 있었잖아요.
01:06:12 비지의 아이들 이런 게 있었잖아요. 어느 정도 날릴 때 치면 그래가지고 우리가 이제 그런 거를 하는 게 여기서 첫 번째 사이클이고요. 두 번째 사이클이 끝날 때 이제 우리가 위드라고 하는 이건 프로세스 오는 데이터죠 그다음에 기본적으로 이제 리드하는 데이터는 슬라이드에서 오겠죠. 그래서 우리가 이제 이 주소에 따라서 어떤 데이터가 언제 올지를 모르기 때문에 이렇게 항상 표시를 할 때 이렇게 데이터 해놓고, 여기다가 주소 값을 쓰게 돼 있어요. 표시해줍니다. 이게 일반적인데 일반적이라는 얘기는 우리가 잘 끝났다는 거고, 잘 끝났다는 걸 어떻게 아느냐 h 레디 신호가 1이 되는 걸 알죠 에이치 레지스먼 이제 하는 얘기는 끝났다 얘기죠 그러면 일단 h 레지스먼 당연히 0이 된다는 얘기는 안 끝났다는 거죠. 안 끝나는 거 이런 거죠.
01:07:05 그럼 이제 우리가 얘가 원래는 주소를 주고 커맨드를 주면은 두 번째 사이트 끝날 때쯤에 얘가 h가 레드가 되면 1이 되면 그때 데이터가 되는 게 맞는데 미드든 라이트든 간에 그럼 이제 라이트 데이터 알고 있는 거죠. 프로세서가 잘 끝났을 줄 알고 여기 데이터를 올려놨어요. 두 번째 사이트에 올려놨는데 레디가 0이야 이건 슬라이브에서 오는 거잖아요. 그러니까 무슨 얘기예요. 네가 데이터를 줬는데 내가 지금 내가 뭐가 바빠 가지고 저장을 못했어. 이런 거잖아요. 그러니까 이제 결국 master널글로 h 레디가 0이 되면 데이터를 계속 그냥 갖다 놓는 거죠. 다음 자리까지 얘가 아직 저장을 못했다고 하니 메디가 아직 0이니까. 안 끝났다고 하니 데이터가 이렇게 계속 얘는 익스텐드 되는 거고, 위드인 경우에는 얘가 0이라고 하면 여기 버스에 데이터를 못 올려놨다는 거잖아요.
01:07:57 그러니까 당연히 이제 여기에는 이 어떤 밸류단 데이터가 있다고 볼 수 없는 거고, 다음 사이클을 하더니, 여기도 아직도 0이야 역시 밸리다 데이터가 없다고 보는 거고, 그 다음에 이제 1이 됐을 때 그때 아 이 벨리다 데이터가 버스니티구나 이렇게 알면 돼요. 그리고 라이스인 경우에는 그냥 아직 쟤도 0이니까. 얘를 계속 데이터를 올려놓을 수밖에 없는 거죠. 날씨 입장에서는 그렇게 얘기를 하고 있습니다. 그래서 여러분이 이제 이렇게 하는 거고요. 그래서 이런 어떤 노트에는 얘를 이해하시면 시험은 높은 노트니까 여러분이 사실은 어떤 주어진 상황에서 어떻게 통신이 이루어지는 걸 갖다가 여러분이 빈칸 채워 넣기 정도의 문제가 나올 겁니다. 그래서 여기 보시면 이런 겁니다.
01:08:50 보면 뭐 이렇게 여러분이 뭐 이렇게 보면 어떤 주소가 가고 다음 사이클에 데이터가 와야 되는데 이게 이제 우리가 좀 복잡한 거는 여기 보시면 이제 주소가 계속 가잖아요. a b c 이렇게 가잖아요. 그럼 이제 문제가 없으면 여기 a에 대한 데이터가 올 거고, 여기에 또 b에 대한 데이터가 올 거고, 파이프라인처럼 뭐 여기 d하고 헷갈리니까 e가 있다고 치면 여기 c에 대한 내용으로 볼 수 있기 때문에 이제 파이프라인이 되는 거죠. 기본적으로는 a에 대한 데이터가 올 때 b라는 새로운 주소가 가고 그러면 원래는 문제가 없으면 여기는 데이터가 와야 돼요. 그래서 이제 좀 헷갈려 보이긴 합니다만 a에 대한 두 번째 사이클의 데이터가 있을 때 여기 이제 h3가 1이잖아요. 문제없이 온 거죠. 라인이 됐든 미드가 됐든 미드 중심으로 생각해도 되고 라인 중심으로 생각해도 되고 이제 해놨는데 그래서 이제 문제가 없으면 끝나는 거고, 그러면 a가 끝나는 거죠.
01:09:46 a에 대한 게 끝나는데 b에 대한 건 다음 사이클이 돼야 되는데 b에 대한 게 여기가 0이야 그러면 안 끝났다는 거니까 일단 1이 될 때까지 기다리는 거죠. 이때까지 라인 데이터는 버스에서 올려놓는 거고, 그다음에 읽어들이는 것은 레드가 1일 때 읽어들이면 되는 거죠. 그전까지는 유효한 데이터 값이 있다고 볼 수 없으니까요? 그래가지고 이렇게 하면 되고요. 그래서 이렇게 하면 되고 우리가 얘가 안 끝났으니까 당연히 주소는 잘 끝났을 줄 알고 c를 올려놨는데 b가 안 끝났으니까 당연히 계속 딜레이가 될 수 있는 거죠. c가 주소가 b가 안 끝났기 때문에 기본적으로 계속 버스에 있는 걸 알 수 있습니다. 그러다가 이제 또 c는 이제 그 다음에 b가 끝난 다음에 다음 사이클이 있기 때문에 이제 이 c가 끝났다고 보시면 돼요. 이렇게 동작한다고 볼 수 있습니다. 기본적으로는 전체적으로 봤을 때 이건 error가 있는 건 아니기 때문에 musponse는 ok입니다.
01:10:46 이 경우에 모든 경우에 있어서 hglb가 0이고 일곱 차이가 있는 거지 error라고 얘기하지 않아요. 이게 ok가 되면서 뭔가 레디 가지고 약간의 딜레이를 집어넣는 거를 하게 된다. 이렇게 그래서 이제 우리가 트랜스퍼 타입 애슨에서 얘기하는 트랜스포 타입은 얘기지만 이제 우리가 벌스의 시작이거나 아니면 벌스가 아니거나 버스가 아닌 경우 첫 번 이럴 때 이제 우리가 넌시 컨설이고요. 그다음에 버스가 진행되는 도중에 마지막까지 이때 시퀀스가 되겠고 그래서 우리가 이 버스트 안에 있는 어떤 리메이닝 트랜스퍼 이거는 싱글 트랜스퍼 버스가 아니거나 아니면 버스트의 시작일 때 버스는 논 시퀀스를 해줘야 되죠.
01:11:45 이거 외울 것까지는 아니지만, 이게 두 비트이기 때문에 얘가 00일 때는 아이들이고 01일 땐 빚이고 10일 땐 넌 시퀀스 비즈일 때는 시퀀스 그런 거예요. 굳이 구현을 한다고 하면 이 정보가 필요할 수 있겠죠. 이제는 그냥 외울 건 아니니까 네 가지 조건을 얘기하는 거고, 여기서 비즈라는 것은 중요하니까 아이돌은 그냥 아무것도 안 보낸다는 뜻이니까. 버스를 갖고 있을 때 아무것도 안 보내는 뜻이고요. 얘는 뭐냐 하면 미니풀론이 있는 밀러브 있었잖아요. 이렇게 벌스트 하는 도중에 도중에 우리가 시작을 알아라고 그러면 시작하면 아이디로 하면 되죠. 늦게 시작하면 되는 거니까 아이디로 하면 되는 거고, 시퀀스 언 시퀀스로 시작을 했어요. 근데 시퀀스가 나오는 과정에서 그러니까 in the mirrornost 어떤 도중에 뭔가 얘가 계속 다음 걸 할 수 없어 master가 그럴 때 여기 bg를 보내는 거죠.
01:12:44 그러면 master 쪽에서 아이들 그러니까 delay를 집어넣는다는 걸 알겠습니다. 그래서 우리가 이렇게 bg가 되겠죠. 아 벌스 도중에만 의미가 있다. 넘어갑시다 드디어 여기는 약간 이름도 좋은 마음인데 하여튼 이제 우리가 버스트의 예를 보고 있는데, 일단 시작이 넌 시퀀스가 되겠죠. 그 다음에 이제 시퀀스 시퀀스 시퀀스가 나와야 되는데 그런데 이제 빚을 놓는 거죠. 이렇게 되면 뭔가 얘가 착착 이루어지는 걸 못하니까 못하니까 보시면 다음 주소가 원래 20이면 20이면 다음에 24가 돼야 되는 게 맞는데 얘가 빚이니까. 이게 거의 사용이 안 되니까. 연장이 되는 거죠.
01:13:43 그래서 원래는 이렇게 순서대로 이렇게 짝짝 매 사이클을 쫙쫙 와야 되는데 데이터가 20 데이터가 두 번째 사이클로 오는 건 문제없이 오는데 여기가 bg이기 때문에 여기 데이터는 유효하지 않은 거죠. 그래서 얘가 연장이 되고 이 데이터가 여기서 나타나겠죠. 이거는 이제 베스터 쪽에서 딜레이를 집어넣는 과정이다. 이렇게 시작을 하고 이거는 결국 버스트인 경우에만 의미가 있습니다. 벌써 아니면 의미 없습니다. 그래서 리잘레드 라이드에 있다든가 비슷하는 거죠. 그리고 이 현재 인크리멘트니까 인크리멘트라는 건 끊임없이 계속 증가가 되는 거예요. 그리고 어떤 주소 값을 보시면 42도 증가하고 있죠. 16진수로 보면 32 뭐 그다음에 36 증가하죠. 하나씩 증가한 것을 알 수 있습니다.
01:14:43 쭉 증가하는 게 이제 우리가 인크리멘팅 버스트고요. 여기 만약 랩이라는 게 나오게 되면 랩핑 버스트라고 해서 어느 주소까지 가게 되면 주소값이 어딘가 다시 적어지는 어떤 걸로 가게 되는 거죠. 어느 시점에 얘가 랩핑이 돼서 어디로 가느냐 그게 이제 여러분이 시험에 잘 나오는 부분이에요. 헷갈리시기 때문에 그랬더니, 그거를 좀 더 설명을 드릴게요. 일단 15분 됐으니까 아 일단 우리가 15분 썼다가 자 쉽시다 혹시 늦게 오신 분 있으면 집에 가서부터 해주시고요.